package app

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/justin/echome-be/config"
	"github.com/justin/echome-be/internal/interfaces"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"

	// docs are generated by Swag CLI, you have to import them.
	_ "github.com/justin/echome-be/docs"
)

// Application represents the main application
type Application struct {
	config  *config.Config
	handler *interfaces.Handlers
	echo    *echo.Echo
}

// NewApplication creates a new application
func NewApplication(config *config.Config, handler *interfaces.Handlers) *Application {
	e := echo.New()

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	e.Use(middleware.CORS())

	// Register routes
	handler.RegisterRoutes(e)

	// Swagger docs route
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	app := &Application{
		config:  config,
		handler: handler,
		echo:    e,
	}

	// Health check endpoint (registered after app creation)
	e.GET("/health", app.healthCheckHandler)

	return app
}

// ValidateServices performs basic validation of all services
func (a *Application) ValidateServices() error {
	log.Println("Validating application services...")

	// Validate configuration
	if err := a.validateConfiguration(); err != nil {
		return fmt.Errorf("configuration validation failed: %w", err)
	}

	// Validate router and handlers
	if a.handler == nil {
		return fmt.Errorf("handlers not initialized")
	}

	router := a.handler.GetRouter()
	if router == nil {
		return fmt.Errorf("router not initialized")
	}

	// Validate that essential routes are registered
	if err := a.validateRoutes(); err != nil {
		return fmt.Errorf("route validation failed: %w", err)
	}

	log.Println("All services validated successfully")
	return nil
}

// validateRoutes checks that essential routes are properly registered
func (a *Application) validateRoutes() error {
	routes := a.echo.Routes()

	// Check for essential WebSocket routes
	essentialRoutes := []string{
		"/ws/asr",
		"/ws/tts",
		"/ws/webrtc/:sessionId/:userId",
		"/ws/voice-conversation/:sessionId/:characterId",
		"/health",
	}

	registeredRoutes := make(map[string]bool)
	for _, route := range routes {
		registeredRoutes[route.Path] = true
	}

	for _, essential := range essentialRoutes {
		if !registeredRoutes[essential] {
			return fmt.Errorf("essential route not registered: %s", essential)
		}
	}

	log.Printf("Validated %d routes, including all essential WebSocket endpoints", len(routes))
	return nil
}

// validateConfiguration validates the application configuration
func (a *Application) validateConfiguration() error {
	if a.config == nil {
		return fmt.Errorf("configuration is nil")
	}

	// Validate server configuration
	if a.config.Server.Port == "" {
		return fmt.Errorf("server port is not configured")
	}

	// Validate AI service configuration
	if a.config.AI.ServiceType == "" {
		return fmt.Errorf("AI service type is not configured")
	}

	// Validate AI service specific configuration
	switch a.config.AI.ServiceType {
	case "alibailian":
		if a.config.ALBL.APIKey == "" {
			return fmt.Errorf("ALBL API key is required for alibailian service")
		}
		if a.config.Aliyun.APIKey == "" {
			return fmt.Errorf("Aliyun API key is required for alibailian service")
		}
	default:
		return fmt.Errorf("unsupported AI service type: %s", a.config.AI.ServiceType)
	}

	// Validate Aliyun configuration if present
	if a.config.Aliyun.APIKey != "" {
		if a.config.Aliyun.Endpoint == "" {
			return fmt.Errorf("Aliyun endpoint is required when API key is provided")
		}
		if a.config.Aliyun.Region == "" {
			return fmt.Errorf("Aliyun region is required when API key is provided")
		}
	}

	return nil
}

// healthCheckHandler provides a health check endpoint
func (a *Application) healthCheckHandler(c echo.Context) error {
	status := map[string]interface{}{
		"status": "healthy",
		"services": map[string]string{
			"server":     "running",
			"ai_service": a.config.AI.ServiceType,
			"websockets": "available",
		},
		"endpoints": map[string][]string{
			"websocket": {
				"/ws/asr",
				"/ws/tts",
				"/ws/webrtc/:sessionId/:userId",
				"/ws/voice-conversation/:sessionId/:characterId",
			},
			"api": {
				"/health",
				"/swagger/*",
			},
		},
	}

	return c.JSON(200, status)
}

// GetEcho returns the Echo instance for testing
func (a *Application) GetEcho() *echo.Echo {
	return a.echo
}

// Run starts the application
func (a *Application) Run() error {
	// Start server in a goroutine
	go func() {
		log.Printf("üöÄ Server starting on port %s", a.config.Server.Port)
		log.Printf("üîó Server URL: http://localhost:%s", a.config.Server.Port)
		log.Printf("üìö API Documentation: http://localhost:%s/swagger/", a.config.Server.Port)
		log.Printf("‚ù§Ô∏è  Health Check: http://localhost:%s/health", a.config.Server.Port)
		log.Printf("ü§ñ AI Service: %s", a.config.AI.ServiceType)

		if err := a.echo.Start(fmt.Sprintf(":%s", a.config.Server.Port)); err != nil && err != http.ErrServerClosed {
			a.echo.Logger.Fatalf("Failed to start server: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shut down the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("üì¥ Shutting down server...")

	// Create a deadline to wait for
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Doesn't block if no connections, but will wait until the timeout deadline
	if err := a.echo.Shutdown(ctx); err != nil {
		a.echo.Logger.Fatal(err)
	}

	log.Println("üëã Server exited gracefully")
	return nil
}
