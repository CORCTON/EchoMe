package app

import (
	"context"
	"fmt"
	"net/http"
	"os/signal"
	"syscall"
	"time"

	"go.uber.org/zap"

	"github.com/justin/echome-be/config"
	"github.com/justin/echome-be/internal/interfaces"
	"github.com/justin/echome-be/internal/middleware"
	"github.com/justin/echome-be/internal/validation"
	"github.com/labstack/echo/v4"
	echomiddleware "github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"
	"golang.org/x/sync/errgroup"

	// docs are generated by Swag CLI, you have to import them.
	_ "github.com/justin/echome-be/docs"
)

// Application represents the main application
type Application struct {
	config    *config.Config
	handler   *interfaces.Handlers
	echo      *echo.Echo
	validator *validation.ConfigValidator
}

// NewApplication creates a new application
func NewApplication(config *config.Config, handler *interfaces.Handlers) *Application {
	e := echo.New()

	// Middleware
	e.Use(echomiddleware.Logger())
	e.Use(echomiddleware.Recover())
	e.Use(echomiddleware.CORS())
	e.Use(middleware.MetricsMiddleware())

	// 添加请求限制中间件
	e.Use(echomiddleware.RateLimiter(echomiddleware.NewRateLimiterMemoryStore(20)))

	// Register routes
	handler.RegisterRoutes(e)

	// Swagger docs route
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	app := &Application{
		config:    config,
		handler:   handler,
		echo:      e,
		validator: validation.NewConfigValidator(),
	}
	return app
}

// GetEcho returns the Echo instance for testing
func (a *Application) GetEcho() *echo.Echo {
	return a.echo
}

// Run starts the application
func (a *Application) Run() error {
	// Create context that listens for the interrupt signal from the OS
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	// Use errgroup for managing server goroutine with error handling
	g, gCtx := errgroup.WithContext(ctx)
	// Start server in a goroutine
	g.Go(func() error {
		// 保留关键的启动日志信息
		zap.L().Info("Server starting",
			zap.String("port", a.config.Server.Port),
			zap.String("api_docs", fmt.Sprintf("http://localhost:%s/swagger/", a.config.Server.Port)),
			zap.String("health_check", fmt.Sprintf("http://localhost:%s/health", a.config.Server.Port)),
			zap.String("ai_service", a.config.AI.ServiceType))

		// Create a listener that will be closed when the context is done
		server := &http.Server{
			Addr:    fmt.Sprintf(":%s", a.config.Server.Port),
			Handler: a.echo,
		}

		// Start server in a separate goroutine to check for context cancellation
		go func() {
			<-gCtx.Done()
			// Create a deadline to wait for
			shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			// 保留关键的关闭日志信息
			zap.L().Info("Shutting down server...")
			if err := server.Shutdown(shutdownCtx); err != nil {
				zap.L().Error("Error during server shutdown", zap.Error(err))
			}
		}()

		// Run server and return error if it fails (not due to graceful shutdown)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			return fmt.Errorf("failed to start server: %w", err)
		}
		return nil
	})

	// Wait for all goroutines to finish or until context is canceled
	if err := g.Wait(); err != nil {
		zap.L().Error("Application error", zap.Error(err))
		return err
	}

	zap.L().Info("Server exited gracefully")
	return nil
}
