package app

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os/signal"
	"syscall"
	"time"

	"github.com/justin/echome-be/config"
	"github.com/justin/echome-be/internal/interfaces"
	"github.com/justin/echome-be/internal/middleware"
	"github.com/justin/echome-be/internal/response"
	"github.com/justin/echome-be/internal/validation"
	"github.com/labstack/echo/v4"
	echomiddleware "github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"
	"golang.org/x/sync/errgroup"

	// docs are generated by Swag CLI, you have to import them.
	_ "github.com/justin/echome-be/docs"
)

// Application represents the main application
type Application struct {
	config    *config.Config
	handler   *interfaces.Handlers
	echo      *echo.Echo
	validator *validation.ConfigValidator
}

// NewApplication creates a new application
func NewApplication(config *config.Config, handler *interfaces.Handlers) *Application {
	e := echo.New()

	// Middleware
	e.Use(echomiddleware.Logger())
	e.Use(echomiddleware.Recover())
	e.Use(echomiddleware.CORS())
	e.Use(middleware.MetricsMiddleware())

	// Ê∑ªÂä†ËØ∑Ê±ÇÈôêÂà∂‰∏≠Èó¥‰ª∂
	e.Use(echomiddleware.RateLimiter(echomiddleware.NewRateLimiterMemoryStore(20)))

	// Register routes
	handler.RegisterRoutes(e)

	// Swagger docs route
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	app := &Application{
		config:    config,
		handler:   handler,
		echo:      e,
		validator: validation.NewConfigValidator(),
	}

	// Health check endpoint (registered after app creation)
	e.GET("/health", app.healthCheckHandler)

	return app
}

// ValidateServices performs basic validation of all services
func (a *Application) ValidateServices() error {
	log.Println("Validating application services...")

	// Validate configuration
	if err := a.validateConfiguration(); err != nil {
		return fmt.Errorf("configuration validation failed: %w", err)
	}

	// Validate router and handlers
	if a.handler == nil {
		return fmt.Errorf("handlers not initialized")
	}

	router := a.handler.GetRouter()
	if router == nil {
		return fmt.Errorf("router not initialized")
	}

	// Validate that essential routes are registered
	if err := a.validateRoutes(); err != nil {
		return fmt.Errorf("route validation failed: %w", err)
	}

	log.Println("All services validated successfully")
	return nil
}

// validateRoutes checks that essential routes are properly registered
func (a *Application) validateRoutes() error {
	routes := a.echo.Routes()

	// Check for essential WebSocket routes
	essentialRoutes := []string{
		"/ws/asr",
		"/ws/tts",
		"/ws/webrtc/:sessionId/:userId",
		"/ws/voice-conversation/:characterId",
		"/health",
	}

	registeredRoutes := make(map[string]bool)
	for _, route := range routes {
		registeredRoutes[route.Path] = true
	}

	for _, essential := range essentialRoutes {
		if !registeredRoutes[essential] {
			return fmt.Errorf("essential route not registered: %s", essential)
		}
	}

	log.Printf("Validated %d routes, including all essential WebSocket endpoints", len(routes))
	return nil
}

// validateConfiguration validates the application configuration
func (a *Application) validateConfiguration() error {
	if a.config == nil {
		return fmt.Errorf("configuration is nil")
	}

	// ‰ΩøÁî®‰∏ìÈó®ÁöÑÈÖçÁΩÆÈ™åËØÅÂô®
	return a.validator.ValidateConfig(a.config)
}

// healthCheckHandler provides a health check endpoint with actual service validation
func (a *Application) healthCheckHandler(c echo.Context) error {
	// Perform actual health checks for each component
	healthStatus := "healthy"
	services := make(map[string]map[string]string)
	errors := []string{}

	// Check server health (basic check - if we're handling this request, server is up)
	serverStatus := "running"
	services["server"] = map[string]string{
		"status":   serverStatus,
		"port":     a.config.Server.Port,
		"protocol": "http",
	}

	// Check AI service configuration
	aiserviceStatus := "configured"
	aiserviceDetails := map[string]string{
		"status":     aiserviceStatus,
		"type":       a.config.AI.ServiceType,
		"timeout":    fmt.Sprintf("%dms", a.config.AI.Timeout),
		"maxRetries": fmt.Sprintf("%d", a.config.AI.MaxRetries),
	}

	// If using Aliyun service, check key and endpoint presence
	if a.config.AI.ServiceType == "alibailian" {
		if a.config.Aliyun.APIKey == "" {
			aiserviceStatus = "error"
			aiserviceDetails["error"] = "Missing API key"
			errors = append(errors, "AI service missing API key")
		}
		if a.config.Aliyun.Endpoint == "" {
			aiserviceStatus = "error"
			aiserviceDetails["error"] = "Missing endpoint"
			errors = append(errors, "AI service missing endpoint")
		}
	}
	services["ai_service"] = aiserviceDetails

	// Check WebSocket availability (routes are validated at startup)
	services["websockets"] = map[string]string{
		"status": "available",
	}

	// Check configuration validity
	configStatus := "valid"
	if err := a.validateConfiguration(); err != nil {
		configStatus = "invalid"
		errors = append(errors, fmt.Sprintf("Configuration error: %v", err))
	}
	services["configuration"] = map[string]string{
		"status": configStatus,
	}

	// Update overall status if any errors found
	if len(errors) > 0 {
		healthStatus = "degraded"
	}

	healthData := map[string]any{
		"status":    healthStatus,
		"timestamp": time.Now().UTC().Format(time.RFC3339),
		"version":   "1.0.0", // Can be retrieved from config or build info
		"services":  services,
		"endpoints": map[string][]string{
			"websocket": {
			"/ws/asr",
			"/ws/tts",
			"/ws/webrtc/:sessionId/:userId",
			"/ws/voice-conversation/:characterId",
		},
			"api": {
				"/health",
				"/swagger/*",
				"/api/characters",
				"/api/characters/search",
				"/api/characters/:id",
				"/api/sessions",
				"/api/sessions/:id",
				"/api/sessions/:id/messages",
			},
		},
	}

	// If there are errors, include them in the response
	if len(errors) > 0 {
		healthData["errors"] = errors
		return c.JSON(http.StatusServiceUnavailable, healthData)
	}

	return response.Success(c, healthData)
}

// GetEcho returns the Echo instance for testing
func (a *Application) GetEcho() *echo.Echo {
	return a.echo
}

// Run starts the application
func (a *Application) Run() error {
	// Create context that listens for the interrupt signal from the OS
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	// Use errgroup for managing server goroutine with error handling
	g, gCtx := errgroup.WithContext(ctx)

	// Start server in a goroutine
	g.Go(func() error {
		log.Printf("üöÄ Server starting on port %s", a.config.Server.Port)
		log.Printf("üîó Server URL: http://localhost:%s", a.config.Server.Port)
		log.Printf("üìö API Documentation: http://localhost:%s/swagger/", a.config.Server.Port)
		log.Printf("‚ù§Ô∏è  Health Check: http://localhost:%s/health", a.config.Server.Port)
		log.Printf("ü§ñ AI Service: %s", a.config.AI.ServiceType)

		// Create a listener that will be closed when the context is done
		server := &http.Server{
			Addr:    fmt.Sprintf(":%s", a.config.Server.Port),
			Handler: a.echo,
		}

		// Start server in a separate goroutine to check for context cancellation
		go func() {
			<-gCtx.Done()
			// Create a deadline to wait for
			shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			log.Println("üì¥ Shutting down server...")
			if err := server.Shutdown(shutdownCtx); err != nil {
				log.Printf("Error during server shutdown: %v", err)
			}
		}()

		// Run server and return error if it fails (not due to graceful shutdown)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			return fmt.Errorf("failed to start server: %w", err)
		}
		return nil
	})

	// Wait for all goroutines to finish or until context is canceled
	if err := g.Wait(); err != nil {
		log.Printf("Application error: %v", err)
		return err
	}

	log.Println("üëã Server exited gracefully")
	return nil
}
