name: CI 构建与部署

on:
  push:
    branches: [ main ]
    paths:
      - 'echome-be/**'
      - 'echome-fe/**'
      - 'deploy/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      force:
        description: 'Force deploy even if no code changes'
        required: false
        default: 'false'

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io
  SERVER_HOST: 115.190.101.38
  DOCKER_COMPOSE_PATH: /opt/echome/deploy/docker-compose.yml

jobs:
  changes:
    name: 变更检测
    runs-on: ubuntu-latest
    outputs:
      be: ${{ steps.filter.outputs.be }}
      fe: ${{ steps.filter.outputs.fe }}
    steps:
      - uses: actions/checkout@v4
      - name: Filter
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            be:
              - 'echome-be/**'
            fe:
              - 'echome-fe/**'

  build-push:
    name: 构建并推送镜像
    needs: changes
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [be, fe]
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
      - name: 计算仓库拥有者小写形式
        id: meta
        run: |
          owner_lower=$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')
          echo "owner_lower=$owner_lower" >> $GITHUB_OUTPUT
      - name: 判断是否跳过当前服务
        id: decide
        run: |
          svc=${{ matrix.service }}
          force=${{ github.event.inputs.force || 'false' }}
          be_changed='${{ needs.changes.outputs.be }}'
          fe_changed='${{ needs.changes.outputs.fe }}'
          echo "service=$svc force=$force be=$be_changed fe=$fe_changed"
          if [ "$svc" = "be" ] && [ "$be_changed" != "true" ] && [ "$force" != "true" ]; then echo "skip=true" >> $GITHUB_OUTPUT; fi
          if [ "$svc" = "fe" ] && [ "$fe_changed" != "true" ] && [ "$force" != "true" ]; then echo "skip=true" >> $GITHUB_OUTPUT; fi
      - name: 跳过提示
        if: steps.decide.outputs.skip == 'true'
        run: echo "当前服务无变更且未强制执行，跳过构建。"
      - name: 设置 QEMU
        if: steps.decide.outputs.skip != 'true'
        uses: docker/setup-qemu-action@v3
      - name: 设置 Docker Buildx
        if: steps.decide.outputs.skip != 'true'
        uses: docker/setup-buildx-action@v3
      - name: 登录 GHCR 镜像仓库
        if: steps.decide.outputs.skip != 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: 构建并推送
        if: steps.decide.outputs.skip != 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.service == 'be' && 'echome-be' || 'echome-fe' }}
          file: ${{ matrix.service == 'be' && 'echome-be/Dockerfile' || 'echome-fe/Dockerfile' }}
          push: true
          tags: |
            ghcr.io/${{ steps.meta.outputs.owner_lower }}/echome-${{ matrix.service }}:latest
            ghcr.io/${{ steps.meta.outputs.owner_lower }}/echome-${{ matrix.service }}:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.meta.outputs.owner_lower }}/echome-${{ matrix.service }}:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ steps.meta.outputs.owner_lower }}/echome-${{ matrix.service }}:buildcache,mode=max

  deploy:
    name: 远程部署
    needs: [build-push, changes]
    runs-on: ubuntu-latest
    # Deploy when build-push succeeded or when forced. This prevents skipping deployment when images were built
    if: ${{ needs.build-push.result == 'success' || github.event.inputs.force == 'true' }}
    steps:
      - name: 准备 SSH 密码登录环境
        run: |
          sudo apt-get update -y && sudo apt-get install -y sshpass
      - name: 计算仓库拥有者小写形式
        id: meta
        run: |
          owner_lower=$(echo "${GITHUB_REPOSITORY_OWNER}" | tr '[:upper:]' '[:lower:]')
          echo "owner_lower=$owner_lower" >> $GITHUB_OUTPUT
      - name: 通过 SSH 远程部署
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ env.SERVER_HOST }}
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
          # 用于 TLS / Traefik 配置（与 SSH 登录 IP 区分）
          SERVER_DOMAIN: ${{ secrets.SERVER_DOMAIN }}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          ALIYUN_API_KEY: ${{ secrets.ALIYUN_API_KEY }}
        run: |
          sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST <<EOF
          set -e
          sudo mkdir -p /opt/echome
          cd /opt/echome
          if [ ! -d deploy ]; then
            mkdir deploy
          fi
          # 生成环境变量文件，传递敏感配置
          echo "ALIYUN_API_KEY=$ALIYUN_API_KEY" > deploy/.env
          # 写入域名与 Let's Encrypt 邮箱（注意：SERVER_HOST 用于 SSH/IP，SERVER_DOMAIN 用于域名）
          echo "SERVER_DOMAIN=$SERVER_DOMAIN" >> deploy/.env
          if [ -n "$LETSENCRYPT_EMAIL" ]; then
            echo "LETSENCRYPT_EMAIL=$LETSENCRYPT_EMAIL" >> deploy/.env
          else
            echo "LETSENCRYPT_EMAIL=admin@$SERVER_DOMAIN" >> deploy/.env
          fi
          echo "已生成 deploy/.env 文件用于传递敏感配置"
          # 安装或重新安装 Docker（若未安装）
          if ! command -v docker >/dev/null 2>&1; then
            echo "未检测到 Docker，开始执行安装脚本...";
            TMP_SCRIPT=/tmp/install_docker.sh
            (curl -fsSL https://gh-proxy.com/https://gist.githubusercontent.com/wusisu/38f800cacf58a84ca6d59e6347a8f6ae/raw/f4d01e1277f5c8aea4f3c9d7157393eac4e25848/install-docker-china.sh -o $TMP_SCRIPT || \
             curl -fsSL https://gh-proxy.com/https://gist.githubusercontent.com/wusisu/38f800cacf58a84ca6d59e6347a8f6ae/raw/f4d01e1277f5c8aea4f3c9d7157393eac4e25848/install-docker.sh -o $TMP_SCRIPT) || { echo 'Download install script failed'; exit 2; }
            chmod +x $TMP_SCRIPT
            sudo bash $TMP_SCRIPT || { echo 'Docker install failed'; exit 3; }
            echo "Docker 安装流程已执行完成。";
          else
            echo "远程主机已安装 Docker，跳过安装步骤。";
          fi
          # 使用 Traefik 作为反向代理并自动申请 Let's Encrypt 证书
          cat > deploy/docker-compose.yml <<'COMPOSE'
          version: '3.8'
          services:
            traefik:
              image: traefik:v3.0
              container_name: traefik
              restart: unless-stopped
              command:
                - --entrypoints.web.address=:80
                - --entrypoints.websecure.address=:443
                - --providers.docker=true
                - --providers.docker.exposedbydefault=false
                - --certificatesresolvers.le.acme.tlschallenge=true
                - --certificatesresolvers.le.acme.email=${LETSENCRYPT_EMAIL}
                - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - ./letsencrypt:/letsencrypt
                - /var/run/docker.sock:/var/run/docker.sock:ro
              env_file:
                - .env

            echome-be:
              image: ghcr.io/${{ steps.meta.outputs.owner_lower }}/echome-be:latest
              container_name: echome-be
              restart: unless-stopped
              labels:
                - "traefik.enable=true"
                - "traefik.http.routers.echome-be.rule=Host(`api.${SERVER_DOMAIN}`)"
                - "traefik.http.routers.echome-be.entrypoints=websecure"
                - "traefik.http.routers.echome-be.tls.certresolver=le"
              env_file:
                - .env

            echome-fe:
              image: ghcr.io/${{ steps.meta.outputs.owner_lower }}/echome-fe:latest
              container_name: echome-fe
              restart: unless-stopped
              labels:
                - "traefik.enable=true"
                - "traefik.http.routers.echome-fe.rule=Host(`www.${SERVER_DOMAIN}`) || Host(`${SERVER_DOMAIN}`)"
                - "traefik.http.routers.echome-fe.entrypoints=websecure"
                - "traefik.http.routers.echome-fe.tls.certresolver=le"
              depends_on:
                - echome-be
          volumes:
            letsencrypt:
              driver: local

          networks:
            default:
              driver: bridge
          COMPOSE
          if [ -n "$GHCR_TOKEN" ] && [ -n "$GHCR_USERNAME" ]; then
            echo "使用账号 $GHCR_USERNAME 登录 ghcr.io"
            echo "$GHCR_TOKEN" | sudo docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin || { echo 'Docker 登录失败'; exit 4; }
          else
            echo "未提供 GHCR 凭据，将尝试匿名拉取（私有镜像可能失败）。"
          fi
          # 确保 letsencrypt 目录和 acme.json 存在且权限正确
          sudo mkdir -p deploy/letsencrypt
          sudo touch deploy/letsencrypt/acme.json
          sudo chmod 600 deploy/letsencrypt/acme.json
          echo "拉取最新镜像..."
          sudo docker compose -f deploy/docker-compose.yml pull
          echo "重新创建并启动容器..."
          sudo docker compose -f deploy/docker-compose.yml up -d
          sudo docker image prune -f || true
          EOF
